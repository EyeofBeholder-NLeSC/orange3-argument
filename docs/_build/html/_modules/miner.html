<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>miner &mdash; Orange3-Argument 0.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=2709fde1"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Orange3-Argument
          </a>
              <div class="version">
                0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../example.html">Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../widget_guis.html">Widget GUIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../autoapi/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Orange3-Argument</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">miner</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for miner</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Argument mining module&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">ast</span> <span class="kn">import</span> <span class="n">literal_eval</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">orangearg.argument.miner.utilities</span> <span class="kn">import</span> <span class="n">check_columns</span>


<div class="viewcode-block" id="select_by_topic">
<a class="viewcode-back" href="../autoapi/miner/index.html#miner.select_by_topic">[docs]</a>
<span class="k">def</span> <span class="nf">select_by_topic</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">topic</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Select arguments mentioning the given topic.</span>

<span class="sd">    Args:</span>
<span class="sd">        data (pd.DataFrame): The argument dataframe that must contain the &#39;topics&#39; column.</span>
<span class="sd">        topic (int): The given topic to select.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if the &#39;topics&#39; value of an argument is stored as something else other than a tuple (e.g. a list).</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Part of the original argument dataframe that only contains arguments mentioning the given topic.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expected_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;topics&quot;</span><span class="p">]</span>
    <span class="n">check_columns</span><span class="p">(</span><span class="n">expected_cols</span><span class="o">=</span><span class="n">expected_cols</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

    <span class="n">select_condition</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">topics</span> <span class="o">=</span> <span class="n">literal_eval</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;topics&quot;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">topics</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>  <span class="c1"># in case of tuple of one item</span>
            <span class="n">select_condition</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">topic</span> <span class="o">==</span> <span class="n">topics</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">topics</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">select_condition</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">topic</span> <span class="ow">in</span> <span class="n">topics</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Topics of the </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">th argument should be a tuple, but </span><span class="si">{</span><span class="n">topics</span><span class="si">}</span><span class="s2"> is given.&quot;</span>
            <span class="p">)</span>

    <span class="n">selection</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">select_condition</span><span class="p">]</span>
    <span class="n">selection</span><span class="p">[</span><span class="s2">&quot;argument_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">selection</span><span class="o">.</span><span class="n">index</span>
    <span class="k">return</span> <span class="n">selection</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_edges">
<a class="viewcode-back" href="../autoapi/miner/index.html#miner.get_edges">[docs]</a>
<span class="k">def</span> <span class="nf">get_edges</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get edges from argument dataframe.</span>

<span class="sd">    Edges (attacks) only exist if the two arguments have different overall scores. Edges are tuple of source and target, which are indices of the corresponding argument in the input dataframe.</span>

<span class="sd">    Args:</span>
<span class="sd">        data (pd.DataFrame): The argument dataframe that must have the &#39;score&#39; column.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[Tuple[int]]: The edge list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expected_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;score&quot;</span><span class="p">]</span>
    <span class="n">check_columns</span><span class="p">(</span><span class="n">expected_cols</span><span class="o">=</span><span class="n">expected_cols</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

    <span class="n">id_combs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">id_combo</span> <span class="ow">in</span> <span class="n">id_combs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">id_combo</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;score&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">id_combo</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="s2">&quot;score&quot;</span><span class="p">]:</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_combo</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">edges</span></div>



<div class="viewcode-block" id="get_edge_weights">
<a class="viewcode-back" href="../autoapi/miner/index.html#miner.get_edge_weights">[docs]</a>
<span class="k">def</span> <span class="nf">get_edge_weights</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get edge weights.</span>

<span class="sd">    Edge weights are computed as the difference between the coherence of the source and that of the target.</span>

<span class="sd">    Args:</span>
<span class="sd">        data (pd.DataFrame): The argument dataframe that must have the &#39;coherence&#39; column.</span>
<span class="sd">        edges (List[Tuple[int]]): The edge list.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[float]: The list of edge weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expected_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;coherence&quot;</span><span class="p">]</span>
    <span class="n">check_columns</span><span class="p">(</span><span class="n">expected_cols</span><span class="o">=</span><span class="n">expected_cols</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

    <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s2">&quot;coherence&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s2">&quot;coherence&quot;</span><span class="p">]</span>
        <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">weights</span></div>



<div class="viewcode-block" id="get_edge_table">
<a class="viewcode-back" href="../autoapi/miner/index.html#miner.get_edge_table">[docs]</a>
<span class="k">def</span> <span class="nf">get_edge_table</span><span class="p">(</span><span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">weights</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the edge dataframe.</span>

<span class="sd">    There will be three columns in the output dataframe, which are &#39;source&#39;, &#39;target&#39;, and &#39;weight&#39;. Together, they describe weighted directed edges from source to target argument. Note that there will be no negative weights in the output dataframe, instead, all values will be replace with their absolute values. For edges with negative weights, we swap their source and target.</span>

<span class="sd">    Args:</span>
<span class="sd">        edges (List[Tuple[int]]): The edge list, which are tuples of source and target argument ids.</span>
<span class="sd">        weights (List[float]): The list of edge weights.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if size of the input lists doesn&#39;t match.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: The result edge dataframe.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Length of edges and weigts are not equal: </span><span class="si">{</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">),</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">])</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="get_node_labels">
<a class="viewcode-back" href="../autoapi/miner/index.html#miner.get_node_labels">[docs]</a>
<span class="k">def</span> <span class="nf">get_node_labels</span><span class="p">(</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">sources</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">targets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get labels of arguments given the attacking network.</span>

<span class="sd">    Arguments are separated into two classes, &#39;supportive&#39; and &#39;defeated&#39;, which generally means reliable and unreliable. The rule of detecting the labels is as follows: if an argument is attacked by another argument who is not attacked by any argument, then this argument is labeled as &#39;defeated&#39;; otherwise, it&#39;s labeled as &#39;supportive&#39;. That means, if an argument appears in `targets`, where its corresponding source doesn&#39;t, this argument will be labeled as &#39;defeated&#39;, and otherwise &#39;supportive&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">        indices (List[int]): The node index list</span>
<span class="sd">        sources (List[int]): The source list of the attacking network.</span>
<span class="sd">        targets (List[int]): The target list of the attacking network.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[str]: The label list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="s2">&quot;supportive&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">targets</span><span class="p">):</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">sources</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;defeated&quot;</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>



<div class="viewcode-block" id="get_node_table">
<a class="viewcode-back" href="../autoapi/miner/index.html#miner.get_node_table">[docs]</a>
<span class="k">def</span> <span class="nf">get_node_table</span><span class="p">(</span>
    <span class="n">arg_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">arguments</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">scores</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">labels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the node dataframe.</span>

<span class="sd">    The node dataframe will contain 4 columns, that are &#39;argument_id&#39;, &#39;argument&#39;, &#39;score&#39;, and &#39;label&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">        arg_ids (List[int]): The argument id list.</span>
<span class="sd">        arguments (List[str]): The argument text list.</span>
<span class="sd">        scores (List[int]): The list of argument overall score.</span>
<span class="sd">        labels (List[str]): The argument label list.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: The result node dataframe.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">&quot;argument_id&quot;</span><span class="p">:</span> <span class="n">arg_ids</span><span class="p">,</span>
            <span class="s2">&quot;argument&quot;</span><span class="p">:</span> <span class="n">arguments</span><span class="p">,</span>
            <span class="s2">&quot;score&quot;</span><span class="p">:</span> <span class="n">scores</span><span class="p">,</span>
            <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="n">labels</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The Netherlands eScience Center and the Human Centered Data Analysis Group in Centrum Wiskunde &amp; Informatica, Netherlands..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>